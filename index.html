<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Building Apps with NativeScript and Angular 2</title>

	<meta charset="utf-8">
	<meta name="description" content="A guide to getting started building apps with NativeScript and Angular 2">
	<meta name="author" content="TJ VanToll">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="css/style.css" rel="stylesheet">
</head>
<body>

<div id="container">
	<div id="header">
		<a href="#" class="menu header-btn" id="toggle-toc"></a>
		<h1>Building Apps with NativeScript and Angular 2</h1>
		<a href="https://github.com/tjvantoll/nativescript-angular-guide" class="github header-btn"></a>
	</div>

	<div id="content-container">
		<div id="toc">
			<div class="toc-heading">Table of Contents</div>
			<div id="toc-padding"></div>
		</div>
		<div id="book">
			<div class="chapter">
				<h2 id="building-apps-with-nativescript-and-angular-2">Building Apps with NativeScript and Angular 2</h2>
<p><img src="images/banner.png" class="banner-image plain" alt="NativeScript and Angular 2 logos"></p>
<p>Welcome to the NativeScript &amp; Angular 2 getting started guide 📚. In this hands-on tutorial, you’ll build a cross-platform iOS and Android app from scratch.</p>
<blockquote>
<p><strong>WARNING 🚧</strong>: This guide is being actively written and is not complete. If you find an error in the guide please report the problem at <a href="https://github.com/tjvantoll/nativescript-angular-guide">https://github.com/tjvantoll/nativescript-angular-guide</a>. Pull requests are also welcome 😀.</p>
</blockquote>
<h3 id="what-is-nativescript-what-is-angular-2-">What is NativeScript? What is Angular 2?</h3>
<p><a href="https://www.nativescript.org/">NativeScript</a>  is a framework for building native iOS and Android apps using JavaScript and CSS. NativeScript renders UIs with the native platform’s rendering engine—no <a href="http://developer.telerik.com/featured/what-is-a-webview/">WebViews</a>—resulting in native-like performance and UX. <a href="https://angularjs.org/">Angular JS</a> is one of the most popular open source JavaScript frameworks for application development.</p>
<p>The latest version of Angular, <a href="https://angular.io/">Angular 2</a>, makes it possible to use Angular outside of a web browser, and developers at <a href="http://www.telerik.com/">Telerik</a> (the company that created and maintains NativeScript) <a href="https://docs.google.com/document/d/1J6fZcVbVa6uONVCJIox2A3Jn5TWgspLufmryfA1OXGk/edit#heading=h.trgonlvb0z3j">have been working closely with developers at Google</a> to make Angular 2 in NativeScript a reality.</p>
<p>The result is a software architecture that allows you to build mobile apps using the same framework—and in some cases the same code—that you use to build Angular 2 web apps, with the performance you’d expect from native code. Let’s look at how it all works by building an app.</p>
<blockquote>
<p><strong>WARNING</strong>: Although NativeScript itself is a production-ready framework that drives <a href="https://www.nativescript.org/showcases">many apps in the app stores today</a>, NativeScript’s Angular integration is still in an alpha stage. If you run into issues when using the Angular integration, please report them on <a href="https://github.com/NativeScript/nativescript-angular">https://github.com/NativeScript/nativescript-angular</a>. If you’re looking for a guide on using the production-ready flavor of NativeScript, head to the <a href="http://docs.nativescript.org/start/getting-started">official Getting Started Guide</a>.</p>
</blockquote>
<h3 id="what-you-re-building">What you&#39;re building</h3>
<p>This guide will walk you through building <a href="https://github.com/NativeScript/sample-Groceries">Groceries</a>, a groceries management app that does the following things:</p>
<ul>
<li>Connects to an existing RESTful service.</li>
<li>Provides user registration and login.</li>
<li>Lets authenticated users add and delete groceries from a list.</li>
<li>Runs cross-platform (iOS and Android).</li>
</ul>
<p>If you follow along to the end, here&#39;s what the finished app will look like on iOS:</p>
<p><img src="images/chapter0/ios/1.png" alt="">
<img src="images/chapter0/ios/2.png" alt="">
<img src="images/chapter0/ios/3.png" alt=""></p>
<p>And here&#39;s what the app will look like on Android:</p>
<p><img src="images/chapter0/android/1.png" alt="">
<img src="images/chapter0/android/2.png" alt="">
<img src="images/chapter0/android/3.png" alt=""></p>
<h3 id="prerequisites">Prerequisites</h3>
<p>This guide assumes that you have some basic knowledge of JavaScript, CSS, and your development machine’s terminal. More specifically:</p>
<ul>
<li><strong>JavaScript</strong>: You should know basic JavaScript concepts, such as how functions, if statements, and loops work.</li>
<li><strong>CSS</strong>: You should know how to write simple CSS selectors, and know how to apply CSS rules as name/value pairs.</li>
<li><strong>The terminal</strong>: You should know how to open a terminal or command-line prompt on your development machine, how to change directories, and how to execute commands.</li>
<li><strong>A text editor or IDE</strong>: You should know the basics of your text editor or IDE of choice. You can use any text editor to build NativeScript apps, however, for the best possible experience you may want to choose an editor with built-in TypeScript support such as <a href="https://code.visualstudio.com/">Visual Studio Code</a>.</li>
</ul>
<p>This guide will <em>not</em> assume you have any knowledge of Angular 2 or TypeScript. When background Angular 2 or TypeScript expertise will help you understand a concept, this guide will link you to the appropriate places in the <a href="https://angular.io/docs/ts/latest/">Angular</a> or <a href="http://www.typescriptlang.org/Handbook">TypeScript</a> documentation.</p>
<p>With that out of the way, let’s get started!</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="getting-up-and-running">Getting up and running</h2>
<p>In this chapter you&#39;re going to start with the basics, including installing the NativeScript CLI, starting a new project, and getting your first app up and running.</p>
<h3 id="install-nativescript-and-configure-your-environment">Install NativeScript and configure your environment</h3>
<p>The NativeScript CLI has a few system requirements you must have in place before building NativeScript apps. As a first step, start by going through the instructions for your operating system:</p>
<ul>
<li><a href="http://docs.nativescript.org/start/ns-setup-win">Windows</a></li>
<li><a href="http://docs.nativescript.org/start/ns-setup-os-x">OS X</a></li>
<li><a href="http://docs.nativescript.org/start/ns-setup-linux">Linux</a></li>
</ul>
<blockquote>
<p><strong>TIP</strong>:</p>
<ul>
<li>Completing the installation instructions can be tricky if you’re new to mobile development. If you get stuck, or you have questions at any point while going through this guide, the <a href="http://developer.telerik.com/wp-login.php?action=slack-invitation">NativeScript Community Slack channel</a> is a great place to ask questions.</li>
<li>If you’re overwhelmed by these requirements, you may also be interested in using NativeScript as part of the <a href="http://www.telerik.com/platform">Telerik Platform</a>. The Telerik Platform provides robust tooling for NativeScript apps, including an IDE that performs iOS and Android builds in the cloud, removing the need to complete these system requirements.</li>
</ul>
</blockquote>
<p>After completing the setup you should have two commands available from your terminal: <code>tns</code>—which is short for <b>T</b>elerik <b>N</b>ative<b>S</b>cript—and <code>nativescript</code>. The two commands are equivalent, so we&#39;ll stick with the shorter <code>tns</code>.</p>
<p>You can verify the installation was successful by running <code>tns</code> in your terminal. You should see something like this:</p>
<pre><code>$ tns
# NativeScript
┌─────────┬─────────────────────────────────────────────────────────────────────┐
│ Usage   │ Synopsis                                                            │
│ General │ $ tns &lt;Command&gt; [Command Parameters] [--command &lt;Options&gt;]          │
│ Alias   │ $ nativescript &lt;Command&gt; [Command Parameters] [--command &lt;Options&gt;] │
└─────────┴─────────────────────────────────────────────────────────────────────┘
</code></pre><h3 id="start-your-app">Start your app</h3>
<p>With the NativeScript CLI installed, it&#39;s time to start building your app. Normally, you would <a href="https://github.com/NativeScript/NativeScript-cli#create-project">use the <code>tns create</code> command to create an empty NativeScript application</a>. For this guide however, we&#39;ve scaffolded out a boilerplate project to act as a starting point for <a href="https://github.com/NativeScript/sample-Groceries">Groceries</a>.</p>
<blockquote>
<p><strong>NOTE</strong>: After completing this guide, if you’d like to start a new NativeScript and Angular 2 app—one that doesn’t clone Groceries—you can use the NativeScript CLI’s <code>tns create</code> command as such:</p>
<pre><code>tns create my-app-name --template https://github.com/NativeScript/template-hello-world-ng
</code></pre></blockquote>
<h4 class="exercise-start">
    <b>Exercise</b>: Get the Groceries starting point
</h4>

<p>Navigate to a folder where you want to keep your app code:</p>
<div class="no-copy-button"></div>

<pre><code>cd the-folder-you-want-groceries-to-be-in
</code></pre><p>Next, assuming you have <a href="http://www.git-scm.com/">git installed</a>, clone the Groceries repo from GitHub:</p>
<pre><code>git clone https://github.com/NativeScript/sample-Groceries.git
</code></pre><p>After that, change to the newly cloned repo&#39;s folder:</p>
<pre><code>cd sample-Groceries
</code></pre><p>Finally, switch to the “angular-start” branch for this guide&#39;s starting point:</p>
<pre><code>git checkout angular-start
</code></pre><blockquote>
<p><strong>TIP:</strong> The “angular-end” branch has the final state of this guide&#39;s tutorial. Feel free to <a href="https://github.com/NativeScript/sample-Groceries/tree/angular-end">refer to the branch on GitHub</a> if you get stuck.</p>
</blockquote>
<div class="exercise-end"></div>

<h3 id="add-target-development-platforms">Add target development platforms</h3>
<p>Your app is now set up, but before you run it, you need to initialize a platform-specific native project for each platform you intend to target.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add the iOS and Android platforms
</h4>

<p>If you&#39;re on a Mac, start by adding the iOS platform:</p>
<pre><code>tns platform add ios
</code></pre><p>Next, add the Android platform with the same <code>platform add</code> command:</p>
<pre><code>tns platform add android
</code></pre><div class="exercise-end"></div>

<blockquote>
<p><strong>IMPORTANT:</strong> You can add platforms only for SDKs that you already have installed on your development machine. If you get errors running <code>tns platform add</code>, refer back to the section on <a href="#install-nativescript-and-configure-your-environment">setting up your development environment</a>.</p>
</blockquote>
<p>The <code>platform add</code> command adds a folder called <code>platforms</code> to your project, and copies all of the required native SDKs into this folder. When you build the application, the NativeScript CLI will copy your application code into the <code>platforms</code> folder so that a native binary can be created.</p>
<h3 id="running-your-app">Running your app</h3>
<p>With the platform initialization complete, you can run your app in an emulator or on devices.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Run your app
</h4>

<p>If you&#39;re on a Mac, start by running the app in an iOS simulator with the following command:</p>
<pre><code>tns run ios --emulator
</code></pre><p>If all went well, you should see something like this:</p>
<p><img src="images/chapter1/ios/1.png" alt="iOS login"></p>
<p>Next, run your app on an Android emulator with the following command:</p>
<pre><code>tns run android --emulator
</code></pre><blockquote>
<p><strong>WARNING</strong>:</p>
<ul>
<li>You must have at least one Android AVD (Android Virtual Device) configured for this command to work. If you get an error, try <a href="http://developer.telerik.com/featured/using-android-emulator-hybrid-mobile-apps-telerik-appbuilder/#managing-avds">setting up an AVD</a> and then run the command again.</li>
<li>If you&#39;re using <a href="https://www.genymotion.com">Genymotion</a>, launch your Genymotion virtual device, and then run <code>tns run android</code>.</li>
</ul>
</blockquote>
<p>If all went well, you should see your app running in an Android emulator:</p>
<p><img src="images/chapter1/android/1.png" alt="Android login"></p>
<div class="exercise-end"></div>

<p>Here are a few other tips for running NativeScript apps.</p>
<blockquote>
<p><strong>TIP</strong>:</p>
<ul>
<li>To run on a USB-connected Android or iOS device, use the same <code>run</code> command without the <code>--emulator</code> flag—i.e. <code>tns run android</code> and <code>tns run ios</code>.</li>
<li>The <code>tns device</code> command lists all USB-connected iOS devices, USB-connected Android devices, and Genymotion virtual devices that <code>tns run</code> can deploy to. Note that <code>tns device</code> does not list iOS simulators.</li>
</ul>
</blockquote>
<h3 id="development-workflow">Development workflow</h3>
<p>At this point, you have the NativeScript CLI downloaded and installed, as well as the iOS and Android dependencies that you need to run your app. Now you need a good workflow that lets you make changes and see results fast. For that we’ll use the <code>tns livesync</code> command.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Your first NativeScript change
</h4>

<p>If your previous <code>tns run ios</code> or <code>tns run android</code> task is still running, type <code>Ctrl+C</code> in your terminal to kill it.</p>
<p>If you’re on a Mac, start an iOS livesync watcher by executing the following command:</p>
<pre><code>tns livesync ios --emulator --watch
</code></pre><p>If you have an Android emulator running, start an Android livesync watcher by executing the following command:</p>
<pre><code>tns livesync android --watch
</code></pre><p>The <code>tns livesync</code> command updates your app by transferring the updated source code to the device or simulator. By adding the <code>--watch</code> flag, the <code>livesync</code> command additionally watches the files in your NativeScript project. Whenever one of those files changes, the command detects the update, and patches your app with the updated code.</p>
<blockquote>
<p><strong>TIP</strong>: You can learn about how this is possible by reading more about <a href="http://developer.telerik.com/featured/nativescript-works/">how NativeScript works</a>.</p>
</blockquote>
<p>To see livesync in action let’s make a small update to your app. Open your project’s <code>app/app.component.ts</code> file in your text editor of choice and change <code>&lt;Label text=&#39;hello world&#39;&gt;&lt;/Label&gt;</code> to <code>&lt;Label text=&#39;hello NativeScript&#39;&gt;&lt;/Label&gt;</code>. Save the file and you should see the app relaunch and the updated text displayed.</p>
<div class="exercise-end"></div> 

<p>In addition to updating your NativeScript app on the fly, the livesync command also shows the output of <code>console.log()</code> statements as your app executes, as well as stack traces when things go wrong. So if your app crashes at any time during this guide, look to the terminal for a detailed report of the problem.</p>
<p>The iOS and Android logs can be a bit noisy, so you might have to scroll up a bit to find the actual problem. For example if I try to call <code>foo.bar()</code> when <code>foo</code> does not exist, here&#39;s the information I get on iOS:</p>
<pre><code>/app/path/to/file.js:14:8: JS ERROR ReferenceError: Can&#39;t find variable: foo
1   0xe3dc0 NativeScript::FFICallback&lt;NativeScript::ObjCMethodCallback&gt;::ffiClosureCallback(ffi_cif*, void*, void**, void*)
</code></pre><p>And here&#39;s the same information in the Android logs:</p>
<pre><code>E/TNS.Native( 2063): ReferenceError: foo is not defined
E/TNS.Native( 2063): File: &quot;/data/data/org.nativescript.groceries/files/app/./views/login/login.js, line: 13, column: 4
</code></pre><blockquote>
<p><strong>TIP</strong>: When you&#39;re trying to debug a problem, try adding <code>console.log()</code> statements in your JavaScript code—exactly as you would in a browser-based application.</p>
<p><strong>WARNING</strong>: Not all changes can be livesync’d in a NativeScript app. For instance, livesync cannot patch native configuration file changes (<code>Info.plist</code>, <code>AndroidManifest.xml</code>, and so forth), new plugin installations, and any other change that requires a full compilation of the application. In those cases, you’ll want to use <code>Ctrl+C</code> to stop livesync, and rerun the application using the <code>tns run ios</code> and <code>tns run android</code> commands. Not to worry though, when situations that require a full compilation come up in this guide, these instructions will be explicitly listed.</p>
</blockquote>
<p>Now that you&#39;ve created an app, configured your environment, and set up your app to run on iOS and Android, you&#39;re ready to start digging into the files that make up a NativeScript app.</p>

			</div>
			<div class="chapter">
				<h2 id="building-the-ui">Building the UI</h2>
<p>Before you start coding the Groceries app it&#39;s important to understand a NativeScript app&#39;s folder structure. It&#39;ll help you understand where to place new files, as well as a bit of what&#39;s going on with NativeScript under the hood.</p>
<p>Go ahead and open your app&#39;s <code>sample-Groceries</code> folder in your text editor of choice and let&#39;s dig in.</p>
<h3 id="directory-structure">Directory structure</h3>
<p>To keep things simple, let&#39;s start by looking at the outer structure of the Groceries app:</p>
<pre><code>.
└── sample-Groceries
    ├── app
    │   └── ...
    ├── hooks
    │   └── ...
    ├── node_modules
    │   ├── angular2
    │   ├── nativescript-angular
    │   ├── tns-core-modules
    │   └── ...
    ├── platforms
    │   ├── android
    │   └── ios
    ├── package.json
    ├── references.d.ts
    └── tsconfig.json
</code></pre><p>Here&#39;s what these various files and folders do:</p>
<ul>
<li><strong>app</strong>: This folder contains all the development resources you need to build your app. You&#39;ll be spending most of your time editing the files in here.</li>
<li><strong>hooks</strong>: This folder contains a series of files the NativeScript CLI uses to preprocess TypeScript code into JavaScript code. You can ignore this folder for now, but after you complete this tutorial you may want to experiment with other preprocessors that NativeScript provides out of the box, such as <a href="http://docs.nativescript.org/core-concepts/transpilers#installing-babel">Babel for JavaScript</a> or <a href="http://www.nativescriptsnacks.com/more/2016/03/14/less-sass.html">SASS for CSS</a>.</li>
<li><strong>node_modules</strong>: This folder contains your app&#39;s npm module dependencies, including Angular 2, TypeScript, and the other modules NativeScript needs to build your app.</li>
<li><strong>node_modules/angular2</strong>: This folder contains the Angular 2 source code. NativeScript does not alter the core Angular 2 source code in any way, instead, NativeScript builds on top of Angular 2 with the nativescript-angular npm module.</li>
<li><strong>node_modules/nativescript-angular</strong>: This folder contains the module that integrates NativeScript-specific functionality into Angular 2. The source code for this module lives at <a href="https://github.com/NativeScript/nativescript-angular">https://github.com/NativeScript/nativescript-angular</a>.</li>
<li><strong>node_modules/tns-core-modules</strong>: This folder contains your app&#39;s NativeScript modules, which are a series of NativeScript-provided JavaScript modules you&#39;ll use to build your app. Each module contains the platform-specific code needed to implement some feature—the camera, http calls, the file system, and so forth—exposed through a platform-agnostic API (e.g. <code>camera.takePicture()</code>). We&#39;ll look at some examples in <a href="#chapter4">chapter 4</a>. The source code for these modules lives at <a href="https://github.com/NativeScript/nativescript">https://github.com/NativeScript/nativescript</a>.</li>
<li><strong>platforms</strong>: This folder contains the platform-specific code NativeScript needs to build native iOS and Android apps. For example in the <code>android</code> folder you&#39;ll find things like your project&#39;s <code>AndroidManifest.xml</code> and .apk executable files. Similarly, the <code>ios</code> folder contains the Groceries&#39; Xcode project and .ipa executables. Note, users on Windows machines will not have an <code>ios</code> folder.</li>
<li><strong>package.json</strong>: This file contains your app&#39;s configuration details, such as your app id, the version of NativeScript you&#39;re using, and also which npm modules your app uses. We&#39;ll take a closer look at how to use this file when we talk about using npm modules in <a href="#plugins-and-npm-modules">chapter 5</a>.</li>
<li><strong>references.d.ts</strong>: This file lists all <a href="http://www.typescriptlang.org/docs/handbook/writing-definition-files.html">TypeScript declaration files</a> that your app uses. We’ll dig into what declaration files are, and how to use them in chapter 4 when we discuss NativeScript modules.</li>
<li><strong>tsconfig.json</strong>: This file contains your app’s TypeScript configuration. Unless you have existing TypeScript expertise, you’ll probably want to leave this file alone for now. If you do have existing experience you may want to tweak these values to suit your personal preferences, however, note that the <code>&quot;experimentalDecorators&quot;</code> and <code>&quot;emitDecoratorMetadata&quot;</code> flags are essential to making NativeScript and Angular 2 work, so don’t remove those. You can refer to the official TypeScript wiki for <a href="https://github.com/Microsoft/TypeScript/wiki/tsconfig.json">detailed documentation on what you can do in a <code>tsconfig.json</code> file</a>.</li>
</ul>
<p>The NativeScript CLI manages the <code>platforms</code> folder for you as you develop and run your app; therefore, it&#39;s a best practice to treat the <code>platforms</code> folder as generated code. The Groceries app includes the <code>platforms</code> folder in its <a href="https://github.com/NativeScript/sample-Groceries/blob/master/.gitignore"><code>.gitignore</code></a> to exclude its files from source control.</p>
<p>Next, let&#39;s dig into the <code>app</code> folder, as that&#39;s where you&#39;ll be spending the majority of your time.</p>
<pre><code>.
└── sample-Groceries
    ├── app
    │   ├── App_Resources
    │   │   ├── Android
    │   │   └── iOS
    │   ├── pages
    │   │   ├── login
    │   │   │   ├── login.html
    │   │   │   └── ...
    │   │   └── ...
    │   ├── shared
    │   │   └── ...
    │   ├── utils
    │   │   └── ...
    │   ├── app.css
    │   ├── app.component.ts
    │   ├── main.ts
    │   └── ...
    └── ...
</code></pre><p>Here&#39;s what these various files and folders do:</p>
<ul>
<li><strong>App_Resources</strong>: This folder contains platform-specific resources such as icons, splash screens, and configuration files. The NativeScript CLI takes care of injecting these resources into the appropriate places in the <code>platforms</code> folder when you execute <code>tns run</code>.</li>
<li><strong>pages</strong>: This folder, specific to the Groceries app, contains the code to build your app&#39;s pages. Each page is made up of a TypeScript file, an optional HTML file, and an optional set of CSS files. The Groceries app starts with two folders for its two pages, a login page, and a list page</li>
<li><strong>shared</strong>: This folder, also specific to the Groceries app, contains any files you need to share between NativeScript apps and Angular-2-built web apps. For Groceries this includes folders containing files with a few classes for talking to backend services, a few model objects, and a <code>config.ts</code> file used to share configuration variables like API keys. We’ll discuss the <code>shared</code> folder, as well as code sharing between native apps and web apps, in detail in section 3.2.</li>
<li><strong>app.css</strong>: This file contains global styles for your app. We&#39;ll dig into app styling in <a href="#css">section 2.3</a>.</li>
<li><strong>app.component.ts</strong>: This primary Angular component that drives your application. Eventually this file will handle routing and application-wide configuration, however for now the file has a simple hello world example that we’ll look at momentarily.</li>
<li><strong>main.ts</strong>: The starting point of Angular 2 applications—web and native.</li>
</ul>
<p>To get a sense of a NativeScript app actually starts up, let’s explore the first few files.</p>
<h3 id="starting-up">Starting up</h3>
<p>The first few files you run in a NativeScript app look almost identical to <a href="https://angular.io/docs/ts/latest/quickstart.html">the first few files you run in an Angular 2 web app</a>. Let’s start with <code>main.ts</code> as that’s the first file executed. Open your <code>app.main.ts</code> file; you should see the code below:</p>
<pre><code class="lang-JavaScript">import {nativeScriptBootstrap} from &quot;nativescript-angular/application&quot;;
import {AppComponent} from &quot;./app.component&quot;;

nativeScriptBootstrap(AppComponent);
</code></pre>
<p>Here you’re using the TypeScript <code>import</code> command to bring in a function—<code>nativescriptBootstrap()</code>—and a <a href="http://www.typescriptlang.org/Handbook#classes">TypeScript class</a>—<code>AppComponent</code>—each of which are defined in separate files. The <code>nativescriptBootstrap()</code> function comes from the “nativescript-angular” npm module, which you may recall contains the code needed to integrate NativeScript and Angular 2. Whereas <a href="https://angular.io/docs/ts/latest/api/platform/browser/bootstrap-function.html">Angular 2’s own <code>bootstrap()</code> function</a> starts an Angular 2 browser app, NativeScript’s bootstrap function starts an Angular 2 native app.</p>
<blockquote>
<p><strong>TIP</strong>: If you’re curious about what <code>nativescriptBootstrap()</code> function actually has to do to startup native iOS and Android apps, remember that all this code is open source for you to explore at any time. The <code>nativescriptBootstrap()</code> function specifically is defined in an <a href="https://github.com/NativeScript/nativescript-angular/blob/master/src/nativescript-angular/application.ts"><code>application.ts</code> file</a> in the <a href="https://github.com/NativeScript/nativescript-angular">NativeScript/nativescript-angular repository</a> on GitHub.</p>
</blockquote>
<p>The bootstrap function, regardless of whether it’s for the web or for native apps, needs to know which Angular component to start the application with. In this case, you’re passing control to a <code>AppComponent</code> component defined in <code>app.component.ts</code>.</p>
<blockquote>
<p><strong>TIP</strong>: In NativeScript we follow Angular 2’s own convention of naming component files with a <code>.component.ts</code> suffix.</p>
</blockquote>
<p>Next, open your app’s <code>app/app.component.ts</code> file; you should see the code below:</p>
<pre><code class="lang-JavaScript">import {Component} from &quot;angular2/core&quot;;

@Component({
  selector: &quot;my-app&quot;,
  template: &quot;&lt;Label text=&#39;hello NativeScript&#39;&gt;&lt;/Label&gt;&quot;
})
export class AppComponent {}
</code></pre>
<p>This file contains an Angular 2 component, which is the primary building block of Angular 2 applications, including NativeScript apps. Let’s break down what’s going on in this file.</p>
<p>First, you again use TypeScript’s <code>import</code> command to bring in externally defined functionality—in this case, the <code>Component</code> class from Angular 2 itself. In Angular 2 a component manages a view, or a piece of the user interface that the user sees. A component can be used to define an individual UI element, or an entire page, and eventually we’ll add a bunch of logic to these components and use them to build an entire app. But for now this component is simple for the purpose of demonstration.</p>
<p>Notice the interesting way that the <code>Component</code> class is used—with the syntax <code>@Component</code>. This is a <a href="https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Decorators.md">TypeScript decorator</a>, which allows you to annotate a TypeScript class or method with additional information. For now, you can think of it as a way of adding some metadata configuration to the currently empty <code>AppComponent</code> class. Specifically, the <code>@Component</code> decorator’s <code>template</code> property tells NativeScript how to render this component on the screen. In fact, the <code>&lt;Label text=&quot;hello NativeScript&quot;&gt;&lt;/Label&gt;</code> syntax is why you saw “hello NativeScript” when you ran this app earlier.</p>
<p>However, this syntax may look a bit odd if you come from a web development background. On the web, the <code>&lt;label&gt;</code> HTML element doesn’t have a <code>text</code> attribute, so what’s going on here. Let’s dive into this by looking at how NativeScript UI elements work.</p>
<blockquote>
<p><strong>NOTE</strong>: Curious about the <code>@Component</code> decorator’s <code>selector</code> property? The property defines how a component can be used within another component’s template. For instance a component that defines its <code>selector</code> with <code>selector: &quot;foo-bar&quot;</code> can be used by another component as <code>template: &quot;&lt;foo-bar&gt;&lt;/foo-bar&gt;&quot;</code>. NativeScript is smart enough to use your first Angular 2 component automatically; therefore, the <code>selector</code> property is currently irrelevant. We’ll use the <code>selector</code> property later in this guide though.</p>
</blockquote>
<h3 id="adding-ui-elements">Adding UI elements</h3>
<p>The primary difference between building an Angular 2 app for the web and an Angular 2 app with NativeScript is in the UI elements that you use. NativeScript apps do not use a browser and do not have a DOM; therefore, elements like <code>&lt;div&gt;</code> and <code>&lt;span&gt;</code> simply do not work.</p>
<p>No worries though, as NativeScript provides an <a href="http://docs.nativescript.org/ui/ui-views">extensive suite of UI elements</a>, each of which are implemented with native iOS and Android controls. For instance, the <a href="http://docs.nativescript.org/ui/ui-views#label"><code>&lt;label&gt;</code> control</a> our previous example used is actually rendered as a <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UILabel_Class/"><code>UILabel</code></a> on iOS and an <a href="http://developer.android.com/reference/android/widget/TextView.html"><code>android.widget.TextView</code></a> on Android. The great thing about using NativeScript though, is that this native details are transparent to use as a developer. You type <code>&lt;label&gt;</code> and let NativeScript handle the rendering details.</p>
<p>Let’s return back to building Groceries. The first screen of Groceries is intended to be a login screen, so let’s replace the current <code>&lt;Label&gt;</code> with something that resembles a typical login screen in a mobile app.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add UI elements to <code>app.component.ts</code>
</h4>

<p>Open <code>app/app.component.ts</code> and replace the existing <code>@Component</code> with the following code:</p>
<pre><code class="lang-JavaScript">@Component({
  selector: &quot;my-app&quot;,
  template: `
    &lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot;
      autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
    &lt;TextField hint=&quot;Password&quot; secure=&quot;true&quot;&gt;&lt;/TextField&gt;

    &lt;Button text=&quot;Sign in&quot;&gt;&lt;/Button&gt;
    &lt;Button text=&quot;Sign up for Groceries&quot;&gt;&lt;/Button&gt;
  `
})
</code></pre>
<div class="exercise-end"></div>

<blockquote>
<p><strong>NOTE</strong>: Notice the back-tick character (`) used with the <code>template</code> property. This character is used to define an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">ES2015 template literal</a>, which TypeScript supports, and which allows you to write multi-line strings without using messy string concatenation.</p>
</blockquote>
<p>This code adds two new NativeScript UI elements: a <a href="http://docs.nativescript.org/ApiReference/ui/text-field/how-to.html">text field</a> and a <a href="http://docs.nativescript.org/ApiReference/ui/button/how-to.html">button</a>. Much like HTML elements, NativeScript UI elements provide attributes to let you configure their behavior and appearance. The code you just added uses the following attributes:</p>
<ul>
<li><code>&lt;TextField&gt;</code><ul>
<li><code>hint</code>: Shows placeholder text that tells the user what to type.</li>
<li><code>keyboardType</code>: The type of keyboard to present to the user for input. <code>keyboardType=&quot;email&quot;</code> shows a keyboard optimized for entering email addresses. NativeScript currently supports <a href="http://docs.nativescript.org/ui/keyboard.html">five types of keyboards</a> for text fields.</li>
<li><code>autocorrect</code>: A boolean attribute that determines whether the mobile operating system should autocorrect user input. In the case of email address text fields, the autocorrect behavior is undesirable.</li>
<li><code>autocapitalizationType</code>: Determines how the operating system should autocapitalize user input. <code>autocapitalizationType=&quot;none&quot;</code> turns autocapitalization off altogether. NativeScript supports <a href="http://docs.nativescript.org/ApiReference/ui/enums/AutocapitalizationType/README.html">four autocapitalization types</a> on text fields.</li>
<li><code>secure</code>: A boolean attribute that determines whether the TextField&#39;s text should be masked, which is commonly done on password fields.</li>
</ul>
</li>
<li><code>&lt;Button&gt;</code><ul>
<li><code>text</code>: Controls the text displayed within the button.</li>
</ul>
</li>
</ul>
<p>After your app updates with this change, you may expect to see a polished login screen, but instead you will see a single <code>&lt;Button&gt;</code> element on the screen:</p>
<p><img src="images/chapter2/ios/1.png" alt="login 1">
<img src="images/chapter2/android/1.png" alt="login 1"></p>
<p>What went wrong? In NativeScript whenever you use more than one UI element, you need to tell NativeScript how to arrange those elements on the screen. Since you’re not doing that currently, NativeScript is incorrectly assuming you want the last element—the <code>&lt;Button&gt;</code>—to take up the whole screen. To arrange these elements, let’s move onto the NativeScript feature for aligning elements on the screen: NativeScript layouts.</p>
<blockquote>
<p><strong>TIP</strong>: The NativeScript docs include a <a href="http://docs.nativescript.org/ui-with-xml">full list of the UI components and attributes</a> with which you can build your apps. You can even <a href="http://docs.nativescript.org/ui-with-xml#custom-components">build your own, custom UI components</a>.</p>
</blockquote>
<h3 id="layouts">Layouts</h3>
<p>NativeScript provides several different layout containers that allow you to place UI elements precisely where you want them to appear. </p>
<ul>
<li>The <a href="http://docs.nativescript.org/ApiReference/ui/layouts/absolute-layout/HOW-TO.html">Absolute Layout</a> lets you position elements using explicit x and y coordinates. This is useful when you need to place elements in exact locations, for example showing an activity indicator widget in the top-left corner of your app.</li>
<li>The <a href="http://docs.nativescript.org/ApiReference/ui/layouts/dock-layout/HOW-TO.html">Dock Layout</a> is useful for placing UI elements at the outer edges of your app. For example, a container docked at the bottom of the screen would be a good location for an ad.</li>
<li>The <a href="http://docs.nativescript.org/ApiReference/ui/layouts/grid-layout/HOW-TO.html">Grid Layout</a> lets you divide your interface into a series of rows and columns, much like a <code>&lt;table&gt;</code> in HTML markup.</li>
<li>The <a href="http://docs.nativescript.org/ApiReference/ui/layouts/stack-layout/HOW-TO.html">Stack Layout</a> lets you stack child UI elements either vertically or horizontally.</li>
<li>The <a href="http://docs.nativescript.org/ApiReference/ui/layouts/wrap-layout/HOW-TO.html">Wrap Layout</a> lets child UI elements flow from one row or column to the next when space is filled.</li>
</ul>
<p>For your login screen, all you need is a simple <code>&lt;StackLayout&gt;</code> for stacking the UI elements on top of each other. In later sections, you&#39;ll use some of the more advanced layouts.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a stack layout to the login screen
</h4>

<p>In <code>app.component.ts</code>, add a <code>&lt;StackLayout&gt;</code> element within your component’s <code>template</code> property. The full component should now look like this:</p>
<pre><code class="lang-JavaScript">@Component({
  selector: &quot;my-app&quot;,
  template: `
    &lt;StackLayout&gt;
      &lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot;
        autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
      &lt;TextField hint=&quot;Password&quot; secure=&quot;true&quot;&gt;&lt;/TextField&gt;

      &lt;Button text=&quot;Sign in&quot;&gt;&lt;/Button&gt;
      &lt;Button text=&quot;Sign up for Groceries&quot;&gt;&lt;/Button&gt;
    &lt;/StackLayout&gt;
  `
})
</code></pre>
<div class="exercise-end"></div>

<p>The stack layout is a UI element, and as such, it has attributes just like the <code>&lt;TextField&gt;</code> and <code>&lt;Button&gt;</code> elements you used in the previous section. Here, the <code>orientation=&quot;vertical&quot;</code> attribute tells the stack layout to arrange its child elements vertically.</p>
<p>After your app updates with this change, you&#39;ll see that your login page’s UI elements stack up:</p>
<p><img src="images/chapter2/ios/2.png" alt="login 2">
<img src="images/chapter2/android/2.png" alt="login 2"></p>
<p>Although the UI elements are in the correct order, they could use some spacing and color to make the app look a bit nicer. To do that let&#39;s look at another NativeScript feature: CSS.</p>
<blockquote>
<p><strong>TIP</strong>:</p>
<ul>
<li>Refer to the NativeScript docs for a <a href="http://docs.nativescript.org/layouts">more detailed look at how NativeScript layouts work</a> and the various things you can do to configure them.</li>
<li>Check out Jen Looper&#39;s article on <a href="https://www.nativescript.org/blog/demystifying-nativescript-layouts">demystifying NativeScript layouts</a> for a more thorough look at NativeScript layouts in action.</li>
</ul>
</blockquote>
<h3 id="global-css">Global CSS</h3>
<p>NativeScript uses a <a href="http://docs.nativescript.org/styling">subset of CSS</a> to change the visual appearance of your app. You can use three mechanisms to add CSS properties to UI components: <a href="http://docs.nativescript.org/styling#application-wide-css">application-wide CSS</a> (<code>app.css</code>), component-specific CSS, and an <a href="http://docs.nativescript.org/styling#inline-css">inline <code>style</code> attribute</a>. In this section we’ll cover application-wide, or global CSS, and in the next section we’ll look at how to apply CSS rules to individual components.</p>
<blockquote>
<p><strong>TIP</strong>: Although inline styles are great for quick testing—e.g. <code>&lt;StackLayout style=&quot;background-color: green;&quot;&gt;</code>—you should avoid them in general because the <code>style</code> attributes tend to clutter up your templates, especially if you need to apply multiple rules.</p>
</blockquote>
<h4 class="exercise-start">
    <b>Exercise</b>: Create global styles
</h4>

<p>Open your app’s <code>app/app.css</code> file and paste in the following code:</p>
<pre><code class="lang-CSS">Page {
  background-color: white;
  font-size: 15;
}
TextField {
  padding: 10;
  font-size: 13;
}
</code></pre>
<div class="exercise-end"></div>

<p>If you&#39;ve done any web development before, the syntax should feel familiar here. You select two UI components by their tag names (Page and TextField), and then apply a handful of CSS rules as name/value pairs. NativeScript does not support all CSS properties because it is not possible to replicate some of them in native apps without causing performance issues. A <a href="http://docs.nativescript.org/styling#supported-properties">full list of the CSS properties that are supported</a> are listed in the NativeScript docs.</p>
<p>Although often you want CSS rules to apply equally to your iOS and Android app, occasionally it makes sense to apply a CSS rule to only one platform. For example, iOS text fields frequently have borders around them, but Android text fields do not. Let&#39;s look at how to make platform-specific style changes in NativeScript.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add platform-specific CSS
</h4>

<p>Add the following as the first line of your app&#39;s <code>app/app.css</code> file:</p>
<pre><code class="lang-CSS">@import url(&quot;~/platform.css&quot;);
</code></pre>
<blockquote>
<p><strong>WARNING</strong>: NativeScript is consistent with browser implementations in that <code>@import</code> statements must precede all other CSS rules in a file.</p>
</blockquote>
<p>Next, open your app’s <code>app/platform.ios.css</code> file and paste in the following code:</p>
<pre><code class="lang-CSS">TextField {
  border-width: 1;
  border-color: black;
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: We’ll leave the <code>platform.android.css</code> file empty as we have no Android-specific changes to make yet.</p>
</blockquote>
<div class="exercise-end"></div>

<p>NativeScript supports CSS&#39;s <code>@import</code> statement for importing one CSS file into another. So this new line of code imports the CSS rules from <code>platform.css</code> into <code>app.css</code>. But, you might have noticed that Groceries does not have a file named <code>platform.css</code>—only <code>app/platform.android.css</code> and <code>app/platform.ios.css</code> exist. What&#39;s going on here?</p>
<p><a id="platform-specific-files"></a>When you execute <code>tns run</code>, or <code>tns livesync</code>, the NativeScript CLI takes your code from the <code>app</code> folder and places it in the native projects located in the <code>platforms/ios</code> and <code>platforms/android</code> folders. Here the naming convention comes in: while moving files, the CLI intelligently selects <code>.android.*</code> and <code>.ios.*</code> files. To give a specific example, the CLI moves <code>platform.ios.css</code> into <code>platforms/ios</code> and renames it to <code>platform.css</code>; similarly, the CLI moves <code>platform.android.css</code> into <code>platforms/android</code>, and again renames it to <code>platform.css</code>. This convention provides a convenient way to branch your code to handle iOS and Android separately, and it&#39;s supported for any type of file in NativeScript—not just CSS files. You&#39;ll see a few more examples of this convention later in this guide.</p>
<p>With these changes in place, you&#39;ll notice that the app has a bit more spacing, and also that the text fields have borders on iOS but that Android:</p>
<p><img src="images/chapter2/ios/3.png" alt="login 3">
<img src="images/chapter2/android/3.png" alt="login 3"></p>
<p>Despite our changes the app still looks pretty ugly, and that’s because we’re going to apply another batch of styles at the component level. Let’s look at how that works.</p>
<h3 id="component-specific-css">Component-specific CSS</h3>
<p>Much like on the web, sometimes in your NativeScript apps you want to write CSS rules that apply to your entire application, and sometimes you want to write CSS rules that apply to a specific portion of the interface. In the previous section you saw how to use NativeScript’s <code>app.css</code> file to write global rules, and in this section you’ll learn how to use a component’s <code>styleUrls</code> property to apply rules that are scoped to individual components.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add component-specific CSS
</h4>

<p>Open your app’s <code>app/app.component.ts</code> file and add a <code>styleUrls</code> property such that that full <code>@Component</code> declaration now looks like this:</p>
<pre><code class="lang-JavaScript">@Component({
  selector: &quot;my-app&quot;,
  template: `
    &lt;StackLayout&gt;
      &lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot;
        autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
      &lt;TextField hint=&quot;Password&quot; secure=&quot;true&quot;&gt;&lt;/TextField&gt;

      &lt;Button text=&quot;Sign in&quot;&gt;&lt;/Button&gt;
      &lt;Button text=&quot;Sign up for Groceries&quot;&gt;&lt;/Button&gt;
    &lt;/StackLayout&gt;
  `,
  styleUrls: [&quot;pages/login/login-common.css&quot;, &quot;pages/login/login.css&quot;]
})
</code></pre>
<p>Next, open your app’s <code>app/pages/login/login.common.css</code> file and paste in the following code:</p>
<pre><code class="lang-CSS">StackLayout {
  margin-left: 30;
  margin-right: 30;
  padding-bottom: 15;
  background-color: white;
}
Image {
  margin-top: 5;
  margin-bottom: 20;
}
Button, TextField {
  margin-left: 16;
  margin-right: 16;
  margin-bottom: 10;
}
#submit-button {
  background-color: #CB1D00;
  color: white;
  margin-top: 20;
}
</code></pre>
<div class="exercise-end"></div>

<p>In Angular 2, the <code>stylesUrl</code> points at an array of stylesheets that should be used to style a component. In this case, you’re telling Angular to use two stylesheets, <code>login-common.css</code>, and <code>login.css</code>, which is actually implemented as <code>login.ios.css</code> and <code>login.android.css</code> using the same naming convention we introduced in the previous section.</p>
<p>Why three files? Much like you divided your global files into <code>app.css</code>, <code>platform.ios.css</code>, and <code>platform.android.css</code>, this structure gives you a similar ability to place common login styling in <code>login-common.css</code>, iOS-specific login styling <code>login.ios.css</code>, and Android-specific login styling in <code>login.android.css</code>.</p>
<p>The great thing about placing CSS rules at the component level is you can use concise CSS selectors such as <code>Button</code> and <code>TextField</code>, and not worry about those rules applying to all buttons and text fields in your application, as Angular 2 ensures those rules remain scoped to your component.</p>
<p>Before we see what your app looks like now, there’s one small change you need to make. Notice that the last selector used in <code>login-common.css</code> is <code>#submit-button</code>. Much like using CSS on the web, in NativeScript you can both <code>id</code> and <code>class</code> attributes to target specific user interface element, but at the moment there’s no UI element in your app with an <code>id</code> of <code>&quot;submit-button&quot;</code>. Let’s change that.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add an <code>id</code> attribute
</h4>

<p>Open your app’s <code>app/app.component.ts</code> file, find <code>&lt;Button text=&quot;Sign in&quot;&gt;&lt;/Button&gt;</code> in your component’s <code>template</code>, and replace it with the code below:</p>
<pre><code class="lang-XML">&lt;Button text=&quot;Sign in&quot; id=&quot;submit-button&quot;&gt;&lt;/Button&gt;
</code></pre>
<div class="exercise-end"></div>

<p>And with this last <code>id</code> change in place your app is starting to look a little nicer:</p>
<p><img src="images/chapter2/ios/4.png" alt="login 4">
<img src="images/chapter2/android/4.png" alt="login 4"></p>
<p>As you can see, in NativeScript you have a lot of options for how you can apply CSS rules. You can apply rules globally—either for both platforms in <code>app.css</code>, for iOS in <code>platform.ios.css</code>, or for Android in <code>platform.android.css</code>. And you can also apply rules at the component level, while maintaining the same flexibility to target different platforms if required.</p>
<p>To continue polishing the visuals of this login screen, let’s look at how we can add an image of this app’s logo.</p>
<h3 id="images">Images</h3>
<p>In NativeScript you use the <code>&lt;Image&gt;</code> UI element and its <code>src</code> attribute to add images to your pages. The <code>src</code> attribute lets you specify your image in three ways. The first (and simplest) way is to point at the URL of an image:</p>
<pre><code class="lang-XML">&lt;Image src=&quot;https://www.nativescript.org/images/default-source/landingpages/logo.png&quot;&gt;&lt;/Image&gt;
</code></pre>
<p>The second way is to point at an image that lives within your app&#39;s <code>app</code> folder. For example if you have an image at <code>app/images/logo.png</code>, you can use it with:</p>
<pre><code class="lang-XML">&lt;Image src=&quot;~/images/logo.png&quot;&gt;&lt;/Image&gt;
</code></pre>
<p>The third way, and the one Groceries uses, is to use platform-specific image resources. Let&#39;s add an image to the login screen and then discuss exactly what&#39;s happening.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a logo
</h4>

<p>In <code>app.component.ts</code>, add the <code>&lt;Image&gt;</code> below as the first child of the existing <code>&lt;StackLayout&gt;</code> tag:</p>
<pre><code class="lang-XML">&lt;Image src=&quot;res://logo_login&quot; stretch=&quot;none&quot; horizontalAlignment=&quot;center&quot;&gt;&lt;/Image&gt;
</code></pre>
<div class="exercise-end"></div>

<p>The <code>res://</code> syntax tells NativeScript to use a platform-specific resource, in this case an image. Platform-specific resources go in your app&#39;s <code>app/App_Resources</code> folder. If you look there you&#39;ll find a few different image files, several of which are named <code>logo_login.png</code>.</p>
<p>Although more complex than putting an image directly in the <code>app</code> folder, using platform-specific images gives you more control over image display on different device dimensions. For example iOS lets you provide three different image files for devices with different pixel densities. As such you&#39;ll find logos named <code>logo_login.png</code>, <code>logo_login@2x.png</code>, and <code>logo_login@3x.png</code> in your <code>App_Resources/iOS</code> folder. For Android you&#39;ll find similar image files in <code>App_Resources/Android/drawable-hdpi</code> (for &quot;high&quot; dpi, or high dots-per-inch), <code>App_Resources/Android/drawable-mdpi</code> (for medium-dpi), and <code>App_Resources/Android/drawable-ldpi</code> (for low-dpi).</p>
<p>Once these files are in place the NativeScript framework knows how to pick the correct file; all you have to do is reference the image using <code>res://</code> and its base file name—i.e. <code>res://logo_login</code>. Here&#39;s what your login screen should look like on iOS and Android:</p>
<p><img src="images/chapter2/ios/5.png" alt="login 5">
<img src="images/chapter2/android/5.png" alt="login 5"></p>
<p>At this point your UI looks good, but the app still doesn&#39;t actually do anything. Let&#39;s look at how you can use JavaScript to add some functionality.</p>
<blockquote>
<p><strong>TIP</strong>: The community-written <a href="http://nsimage.brosteins.com/">NativeScript Image Builder</a> can help you generate images in the appropriate resolutions for iOS and Android.</p>
</blockquote>

			</div>
			<div class="chapter">
				<h2 id="application-logic">Application Logic</h2>
<p>In this chapter you’ll learn how to add JavaScript logic to your app, how to create services that talk to backend endpoints, and how to architect an app that uses multiple pages. There’s a lot to cover, so let’s start by discussing how to handle events and data binding.</p>
<h3 id="events">Events</h3>
<p>Most user interfaces are driven by events. In NativeScript apps, those events are usually some user action, such as tapping, swiping, or rotating—and NativeScript abstracts the iOS- and Android-specific code for handling such events into a handful of easy-to-use APIs. Let’s start with the most common event you’ll use in a NativeScript app: <code>tap</code>.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a <code>tap</code> event handler
</h4>

<p>Open <code>app/app.component.ts</code>, find the existing sign in button within your component’s <code>template</code> (<code>&lt;Button text=&quot;Sign in&quot;&gt;&lt;/Button&gt;</code>), and replace it with the following code:</p>
<pre><code class="lang-JavaScript">&lt;Button text=&quot;Sign in&quot; id=&quot;submit-button&quot; (tap)=&quot;submit()&quot;&gt;&lt;/Button&gt;
</code></pre>
<p>Next, in the same file, replace the current <code>AppComponent</code> declaration with the one shown below:</p>
<pre><code class="lang-JavaScript">export class AppComponent {
  submit() {
    console.log(&quot;hello&quot;);
  }
}
</code></pre>
<div class="exercise-end"></div>

<p>The <code>(eventName)=&quot;functionName()&quot;</code> syntax is part of <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#!#event-binding">Angular 2’s event binding system</a>, which lets you bind an event that occurs on a UI element to a function in your component’s class. In this case, the <code>(tap)=&quot;submit()&quot;</code> syntax tells Angular to run the <code>AppComponent</code> class’s <code>submit()</code> function whenever the user taps the sign in button.</p>
<p>To verify this binding works tap the “Sign In” button in your app; you should see “hello” logged in your terminal or command prompt as such:</p>
<p><img alt="Terminal showing the word hello logged" src="images/chapter3/terminal-1.png" class="plain"></p>
<blockquote>
<p><strong>TIP</strong>:</p>
<ul>
<li>In NativeScript you can find a list of events available in the appropriate UI element’s API documentation. For instance, the <a href="http://docs.nativescript.org/ApiReference/ui/button/Button">button element’s API documentation</a> lists its <code>tap</code> event.</li>
<li>The Angular 2 docs have a helpful <a href="https://angular.io/docs/ts/latest/guide/cheatsheet.html">cheat sheet</a> that includes the various syntaxes available when building templates. Don’t worry too much about knowing how all these work at the moment; we’ll progressively introduce the most common syntaxes in this guide.</li>
</ul>
</blockquote>
<p>With the <code>tap</code> event in place, you now have a way of tying the UI elements in your template to your TypeScript code. To make a login page actually work though, we need to introduce one other way of connecting a template to code: data binding.</p>
<h3 id="data-binding">Data Binding</h3>
<p>Angular 2 provides several ways to bind data in your TypeScript code to UI controls, and through the magic of NativeScript those same methods are available in your iOS and Android apps.</p>
<p>The first of these is a way to bind UI attributes to properties defined in your TypeScript class. Let’s look at how it works.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Using Angular 2 attribute binding
</h4>

<p>In <code>app/app.component.ts</code> replace the current <code>AppComponent</code> declaration with the one shown below, which adds a new <code>email</code> property, and changes the <code>submit()</code> method to display its value:</p>
<pre><code class="lang-TypeScript">export class AppComponent {
  email = &quot;nativescriptrocks@telerik.com&quot;;
  submit() {
    alert(&quot;You’re using: &quot; + this.email);
  }
}
</code></pre>
<p>Next, find the first <code>&lt;TextField&gt;</code> in your component’s <code>template</code> and replace it with the code below, which adds a new <code>text</code> attribute:</p>
<pre><code class="lang-XML">&lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot; [text]=&quot;email&quot;
  autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
</code></pre>
<div class="exercise-end"></div>

<p>The key thing to note here is the <code>[text]=&quot;email&quot;</code> attribute on the <code>&lt;TextField&gt;</code>. This is Angular 2’s syntax for attribute binding, and it allows you to bind the value of an attribute to a property in your TypeScript class. In this case, the <code>text</code> attribute of the <code>&lt;TextField&gt;</code>—which is roughly equivalent to a DOM <code>&lt;input&gt;</code>’s <code>value</code> attribute—is bound to the <code>AppComponent</code>’s <code>email</code> attribute. Therefore the app now has an email address prefilled when it loads:</p>
<p><img src="images/chapter3/android/1.png" alt="Android with prefilled email">
<img src="images/chapter3/ios/1.png" alt="iOS with prefilled email"></p>
<blockquote>
<p><strong>NOTE</strong>: It’s very easy to confuse Angular 2’s event binding syntax <code>(eventName)=&quot;functionName()&quot;</code> with its attribute binding syntax <code>[attributeName]=&quot;propertyName&quot;</code> 🤔. Don’t worry though; if you get them backwards, the problem is usually easy to debug, as the functionality you’re attempting to add just won’t work. These syntaxes are common enough that you’ll be using them a lot, and eventually you should be able to commit them to memory.</p>
</blockquote>
<p>This attribute binding approach works really well when you need the data binding to be one way—that is, when you need TypeScript properties, and changes to those properties done in TypeScript code, to appear in the user interface. But in the case of user interface controls that accept user input, such as the text field in this example, usually you need data binding to work two way—that is, you additionally need changes the user makes to be reflected in your TypeScript code.</p>
<p>To show that the current example’s data binding is only one way, head back to your app, change the email text field’s value (type a few extra letters or something like that), and then tap the “Sign In” button. Because your <code>submit()</code> function alerts the current value of your component’s <code>email</code> property—<code>alert(&quot;You’re using: &quot; + this.email)</code>—you might expect to see the updated value in the alert. Instead, however, you see the original value. Notice how the typed text and the alert value don’t match in the screenshot below.</p>
<p><img src="images/chapter3/android/2.png" alt="Android with email address that do not match"></p>
<p>To fix this, you need to switch to Angular 2’s two-way data binding syntax.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Two-way data binding with Angular 2
</h4>

<p>In <code>app/app.component.ts</code>, find the find the first <code>&lt;TextField&gt;</code>, and replace it with the <code>&lt;TextField&gt;</code> below, which introduces a new <code>[(ngModel)]</code> attribute:</p>
<pre><code class="lang-XML">&lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot; [(ngModel)]=&quot;email&quot;
  autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
</code></pre>
<div class="exercise-end"></div>

<p>At first glance the <code>[(ngModel)]</code> syntax looks more than a little odd, as it’s essentially a combination of the event and attribute binding syntax that you used in earlier examples. In the case of this example, <code>[(ngModel)]=&quot;email&quot;</code> is shorthand for <code>[text]=&quot;email&quot; (emailChange)=&quot;email=$event&quot;</code>, which binds the email element’s <code>text</code> attribute to an <code>email</code> property, as well as adds a <code>change</code> event handler that updates the <code>email</code> property’s value whenever the user makes a change.</p>
<p>Don’t worry too much about the details here while we’re still getting started. In your head you can think of <code>[(ngModel)]</code> as the way to implement two-way data binding when you need it on form controls. And to show that it works, if you again modify your app’s email address and click the “Sign In” button, you’ll see the updated value in the alert as expected:</p>
<p><img src="images/chapter3/android/3.png" alt="Android with email addresses that do match"></p>
<p>At this point, you have a basic login screen setup with two-way data binding—not bad for 20 some lines of code of TypeScript. (Think about how much code you’d have to write in Android Studio <em>and</em> Xcode to accomplish the same task.) To this point though you’ve been placing all of your logic in a single TypeScript file, which doesn’t scale all that well for real-world applications.</p>
<p>TODO: Transition</p>
<h4 class="exercise-start">
    <b>Exercise</b>: ???
</h4>

<p>app.component.ts — Replace the two buttons with this</p>
<pre><code class="lang-XML">&lt;Button [text]=&quot;isLoggingIn ? &#39;Sign in&#39; : &#39;Sign up&#39;&quot; id=&quot;submit-button&quot; (tap)=&quot;submit()&quot;&gt;&lt;/Button&gt;
&lt;Button [text]=&quot;isLoggingIn ? &#39;Sign up&#39; : &#39;Back to login&#39;&quot; (tap)=&quot;toggleDisplay()&quot;&gt;&lt;/Button&gt;
</code></pre>
<p>app.component.ts - Use this for the AppComponent class:</p>
<pre><code class="lang-TypeScript">export class AppComponent {
  email = &quot;nativescriptrocks@telerik.com&quot;;
  isLoggingIn = true;

  submit() {
    alert(&quot;You’re using: &quot; + this.email);
  }
  toggleDisplay() {
    this.isLoggingIn = !this.isLoggingIn;
  }
}
</code></pre>
<div class="exercise-end"></div>

<p>TODO: Transition</p>
<p>Before we tie this app to a backend and make this login screen fully functional, let’s take a step back and setup a structure that can scale.</p>
<h3 id="structuring-your-app">Structuring your app</h3>
<p>There are many reasons to segment any application into modular units, and you can <a href="https://en.wikipedia.org/wiki/Modular_programming">read about the various benefits on Wikipedia</a>. However, keeping NativeScript apps modular has one unique benefit: the ability to share the code you write between Angular-2-built web apps, and Angular-2-built native apps.</p>
<p>Even if you have no plans to create an Angular 2 web app, separating out your code is still advantageous for a number of other reasons—testability, ease of maintenance, and so forth—but if you <em>do</em> have plans to build an Angular 2 web app, having a chunk of functionality that you can reuse in your native and web apps can be an invaluable time saver.</p>
<p>To see how this works in action, let’s edit some files in the <code>/shared</code> folder and set them up to be imported.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a model object
</h4>

<p>Let’s start by creating a simple model object to store user data. Open <code>app/user/user.ts</code> and paste in the following code:</p>
<pre><code class="lang-JavaScript">export class User {
  email: string;
  password: string;
}
</code></pre>
<p>This code defines a simple <a href="http://www.typescriptlang.org/Handbook#classes">TypeScript class</a> that does nothing more than define two properties—<code>email</code> and <code>password</code>. Note the use of <a href="http://www.typescriptlang.org/Handbook#modules-going-external">TypeScript’s <code>export</code> keyword</a>, as we’ll see why that’s important momentarily.</p>
<p>Next, open <code>app/app.component.ts</code>, and first add the following <code>import</code> to the top of the file:</p>
<pre><code class="lang-JavaScript">import {User} from &quot;./shared/user/user&quot;;
</code></pre>
<p>Here you import the <code>User</code> class that you just defined. Note the parallel between the <code>export</code> command used in the previous example and the <code>import</code> command used here. The reason the <code>User</code> class is available to import is because it was explicitly exported. You’ll see other examples of <code>import</code> and <code>export</code> as you go through this guide.</p>
<p>Next, replace the existing <code>AppComponent</code> definition with the one below, which uses the <code>User</code> class you just imported.</p>
<pre><code class="lang-JavaScript">export class AppComponent {
  user: User;
  isLoggingIn = true;

  constructor() {
    this.user = new User();
  }
  submit() {
    alert(&quot;You’re using: &quot; + this.user.email);
  }
  toggleDisplay() {
    this.isLoggingIn = !this.isLoggingIn;
  }
}
</code></pre>
<p>Instead of storing data on the <code>AppComponent</code> directly, you’re now using the <code>User</code> model object, which is reusable outside of this page and even outside of this application. You instantiate an instance of the <code>User</code> class in a new <code>constructor</code> function, which Angular 2 invokes when it bootstraps your application.</p>
<p>Your final step is to use this new model object in your template. To do that, replace the two existing <code>&lt;TextField&gt;</code>s with the code shown below, which updates the <code>[(ngModel)]</code> bindings to point at the new <code>User</code> object:</p>
<pre><code class="lang-XML">&lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot; [(ngModel)]=&quot;user.email&quot;
  autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
&lt;TextField hint=&quot;Password&quot; secure=&quot;true&quot; [(ngModel)]=&quot;user.password&quot;&gt;&lt;/TextField&gt;
</code></pre>
<p>TODO: Better explanation. Move the full template into the login.html file and use <code>templateUrl</code>. </p>
<p>If you got lost during this section, here’s a copy-and-paste friendly version of the full <code>app.component.ts</code> you should have at this point:</p>
<pre><code class="lang-JavaScript">import {Component} from &quot;angular2/core&quot;;
import {User} from &quot;./shared/user/user&quot;;

@Component({
  selector: &quot;my-app&quot;,
  templateUrl: &quot;pages/login/login.html&quot;,
  styleUrls: [&quot;pages/login/login-common.css&quot;, &quot;pages/login/login.css&quot;]
})
export class AppComponent {
  user: User;
  isLoggingIn = true;

  constructor() {
    this.user = new User();
  }
  submit() {
    alert(&quot;You’re using: &quot; + this.user.email);
  }
  toggleDisplay() {
    this.isLoggingIn = !this.isLoggingIn;
  }
}
</code></pre>
<div class="exercise-end"></div>

<p>With this setup you now have a <code>User</code> class that you can share across pages in your app and even across applications. But a model object that’s four simple lines of code isn’t all that exciting. Where this approach really pays off is when you’re able to share your business logic, and the code that hits your backend systems. In Angular 2 those classes are known as services. Let’s look at them next.</p>
<h3 id="services">Services</h3>
<p>A login screen isn’t all that useful if it doesn’t actually log users into anything. Therefore, our next task is to take the user’s email address and password, and send them to a backend endpoint to retrieve an authentication token we’ll use later in this guide. We’ll build this functionality as an Angular 2 service.</p>
<p>For the purposes of this tutorial we prebuilt a handful of backend endpoints using <a href="http://www.telerik.com/platform/backend-services">Telerik Backend Services</a>, and we’ll be using those endpoints to make this app functional. Let’s see how they work.</p>
<blockquote>
<p><strong>NOTE</strong>: You don&#39;t have to use Telerik Backend Services to hit your app’s backend; you can use any HTTP API in a NativeScript app. Telerik Backend Services is convenient for us to use for this tutorial because it lets us spin up HTTP endpoints quickly.</p>
</blockquote>
<h4 class="exercise-start">
    <b>Exercise</b>: Add an Angular 2 service
</h4>

<p>Open <code>app/shared/user/user.service.ts</code> and paste in the following code:</p>
<pre><code class="lang-TypeScript">import {Injectable} from &quot;angular2/core&quot;;
import {Http, Headers, Response} from &quot;angular2/http&quot;;
import {User} from &quot;./user&quot;;
import {Config} from &quot;../config&quot;;
import {Observable} from &quot;rxjs/Rx&quot;;
import &quot;rxjs/add/operator/do&quot;;
import &quot;rxjs/add/operator/map&quot;;

@Injectable()
export class UserService {
  constructor(private _http: Http) {}

  register(user: User) {
    var headers = new Headers();
    headers.append(&quot;Content-Type&quot;, &quot;application/json&quot;);

    return this._http.post(
      Config.apiUrl + &quot;Users&quot;,
      JSON.stringify({
        Username: user.email,
        Email: user.email,
        Password: user.password
      }),
      { headers: headers }
    )
    .catch(this.handleErrors);
  }

  handleErrors(error: Response) {
    console.log(JSON.stringify(error.json()));
    return Observable.throw(error);
  }
}
</code></pre>
<p>TODO: Explain that mess above, and probably break it into a lot of steps.</p>
<p>In app.component.ts. Add the lines below to the top:</p>
<pre><code class="lang-TypeScript">import {HTTP_PROVIDERS} from &quot;angular2/http&quot;;
import {UserService} from &quot;./shared/user/user.service&quot;;
</code></pre>
<p>Then change the constructor to this:</p>
<pre><code class="lang-TypeScript">constructor(private _userService: UserService) {
  this.user = new User();
}
</code></pre>
<p>Add this line to the @Component:</p>
<pre><code class="lang-TypeScript">providers: [UserService, HTTP_PROVIDERS]
</code></pre>
<p>Then change the submit function to this:</p>
<pre><code class="lang-TypeScript">submit() {
  if (this.isLoggingIn) {
    this.login();
  } else {
    this.signUp();
  }
}
</code></pre>
<p>Then add these two functions:</p>
<pre><code class="lang-TypeScript">login() {
  // TODO: Define
}
signUp() {
  this._userService.register(this.user)
    .subscribe(
      () =&gt; {
        alert(&quot;Your account was successfully created.&quot;);
        this.toggleDisplay();
      },
      () =&gt; alert(&quot;Unfortunately we were unable to create your account.&quot;)
    );
}
</code></pre>
<p>Create an account, then hardcode those credentials in your constructor to make testing easier:</p>
<pre><code class="lang-TypeScript">constructor(private _userService: UserService) {
  this.user = new User();
  this.user.email = &quot;nativescriptrocks@telerik.com&quot;;
  this.user.password = &quot;password&quot;;
}
</code></pre>
<p>Full app.component.ts:</p>
<pre><code class="lang-TypeScript">import {Component} from &quot;angular2/core&quot;;
import {HTTP_PROVIDERS} from &quot;angular2/http&quot;;
import {User} from &quot;./shared/user/user&quot;;
import {UserService} from &quot;./shared/user/user.service&quot;;

@Component({
  selector: &quot;my-app&quot;,
  templateUrl: &quot;pages/login/login.html&quot;,
  styleUrls: [&quot;pages/login/login-common.css&quot;, &quot;pages/login/login.css&quot;],
  providers: [UserService, HTTP_PROVIDERS]
})
export class AppComponent {
  user: User;
  isLoggingIn = true;

  constructor(private _userService: UserService) {
    this.user = new User();
    this.user.email = &quot;nativescriptrocks@telerik.com&quot;;
    this.user.password = &quot;password&quot;;
  }
  submit() {
    if (this.isLoggingIn) {
      this.login();
    } else {
      this.signUp();
    }
  }
  login() {
    // TODO: Define
  }
  signUp() {
    this._userService.register(this.user)
      .subscribe(
        () =&gt; {
          alert(&quot;Your account was successfully created.&quot;);
          this.toggleDisplay();
        },
        () =&gt; alert(&quot;Unfortunately we were unable to create your account.&quot;)
      );
  }
  toggleDisplay() {
    this.isLoggingIn = !this.isLoggingIn;
  }
}
</code></pre>
<div class="exercise-end"></div>

<p>TODO: Show that user account creation now works and transition to routing.</p>
<h3 id="routing">Routing</h3>
<p>TODO: Intro</p>
<h4 class="exercise-start">
    <b>Exercise</b>: ???
</h4>

<p>Copy app/app.component.ts into app/pages/login/login.component.ts, change the name of the class from “AppComponent” to “LoginPage, and update the two paths below accordingly:</p>
<pre><code class="lang-TypeScript">import {User} from &quot;../../shared/user/user&quot;;
import {UserService} from &quot;../../shared/user/user.service&quot;;
</code></pre>
<p>Open app/app.component.ts back up and paste in the following code:</p>
<pre><code class="lang-TypeScript">import {Component} from &quot;angular2/core&quot;;
import {HTTP_PROVIDERS} from &quot;angular2/http&quot;;
import {RouteConfig} from &quot;angular2/router&quot;;
import {NS_ROUTER_DIRECTIVES, NS_ROUTER_PROVIDERS} from &quot;nativescript-angular/router&quot;;
import {LoginPage} from &quot;./pages/login/login.component&quot;;

@Component({
  selector: &quot;main&quot;,
  directives: [NS_ROUTER_DIRECTIVES],
  providers: [NS_ROUTER_PROVIDERS],
  template: &quot;&lt;page-router-outlet&gt;&lt;/page-router-outlet&gt;&quot;
})
@RouteConfig([
  { path: &quot;/Login&quot;, component: LoginPage, as: &quot;Login&quot;, useAsDefault: true },
])
export class AppComponent {}
</code></pre>
<p>Explain what’s going on here.</p>
<div class="exercise-end"></div>

<p>Let’s actually log the user in then, shall we?</p>
<h4 class="exercise-start">
    <b>Exercise</b>: ???
</h4>

<p>Open pages/list/list.component.ts and paste in this:</p>
<pre><code class="lang-TypeScript">import {Component} from &quot;angular2/core&quot;;

@Component({
  selector: &quot;list&quot;,
  templateUrl: &quot;pages/list/list.html&quot;,
  styleUrls: [&quot;pages/list/list-common.css&quot;, &quot;pages/list/list.css&quot;]
})
export class ListPage {}
</code></pre>
<p>Next, open pages/list/list.html and paste in this:</p>
<pre><code class="lang-XML">&lt;Label text=&quot;Hello world&quot;&gt;&lt;/Label&gt;
</code></pre>
<p>Now, go back to app/app.component.ts and paste in this at the top of the file:</p>
<pre><code class="lang-TypeScript">import {ListPage} from &quot;./pages/list/list.component&quot;;
</code></pre>
<p>And this in the <code>@RouteConfig</code>:</p>
<pre><code class="lang-TypeScript">{ path: &quot;/List&quot;, component: ListPage, as: &quot;List&quot; }
</code></pre>
<p>Now go to app/shared/user/user.service.ts and add this function:</p>
<pre><code class="lang-TypeScript">login(user: User) {
  var headers = new Headers();
  headers.append(&quot;Content-Type&quot;, &quot;application/json&quot;);

  return this._http.post(
    Config.apiUrl + &quot;oauth/token&quot;,
    JSON.stringify({
      username: user.email,
      password: user.password,
      grant_type: &quot;password&quot;
    }),
    { headers: headers }
  )
  .map(response =&gt; response.json())
  .do(data =&gt; {
    Config.token = data.Result.access_token;
  })
  .catch(this.handleErrors);
}
</code></pre>
<p>Finally, go to <code>app/login/login.component.ts</code> and change the login function to do this:</p>
<pre><code class="lang-TypeScript">this._userService.login(this.user)
  .subscribe(
    () =&gt; this._router.navigate([&quot;List&quot;]),
    (error) =&gt; alert(&quot;Unfortunately we could not find your account.&quot;)
  );
</code></pre>
<p>To make this work, in the same file, add this to the top:</p>
<pre><code class="lang-TypeScript">import {Router} from &quot;angular2/router&quot;;
</code></pre>
<p>And this to the constructor:</p>
<pre><code class="lang-TypeScript">constructor(private _router: Router, private _userService: UserService) {
</code></pre>
<div class="exercise-end"></div>

<p>You can login now! And navigate! Show a gif of the navigation. Talk about how in NativeScript you get native behavior automatically—aka a back button on iOS and a hardware back button on Android.</p>
<p>Then transition to modules.</p>

			</div>
			<div class="chapter">
				<h2 id="nativescript-modules">NativeScript modules</h2>
<p>Explain what modules are. Should be able to copy content almost verbatim from the current guide.</p>
<h3 id="ui-elements">UI elements</h3>
<p>Explain that UI elements are actually NativeScript modules. Say that we’re going to make this app look nice—it’s a native app after all.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: ???
</h4>

<p>In app/pages/login/login.component.ts, first add these imports:</p>
<pre><code class="lang-TypeScript">import {topmost} from &quot;ui/frame&quot;;
import {Page} from &quot;ui/page&quot;;
</code></pre>
<p>Then include <code>OnInit</code> in the existing <code>&quot;angular2/core&quot;</code> import:</p>
<pre><code class="lang-TypeScript">import {Component, OnInit} from &quot;angular2/core&quot;;
</code></pre>
<p>Add the following as a new property in the <code>LoginPage</code> class:</p>
<pre><code class="lang-TypeScript">page: Page;
</code></pre>
<p>Then add the following function to the <code>LoginPage</code> class:</p>
<pre><code class="lang-TypeScript">ngOnInit() {
  this.page = &lt;Page&gt;topmost().currentPage;
  this.page.actionBarHidden = true;
  this.page.backgroundImage = this.page.ios ? &quot;res://bg_login.jpg&quot; : &quot;res://bg_login&quot;;
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: The <code>this.page.ios</code> check can go away in 2.0. It’s there because of <a href="https://github.com/NativeScript/NativeScript/issues/1788">this bug</a>.</p>
</blockquote>
<div class="exercise-end"></div>

<p>Explain what <code>OnInit</code> is. Explain how to look up {N} modules on the docs. Show images of what the app looks like now.</p>
<p>Transition to animations</p>
<h3 id="animations">Animations</h3>
<p>Talk about animations and the animation module.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: ???
</h4>

<p>Open <code>app/pages/login/login.html</code> and add an <code>id</code> to the <code>&lt;StackLayout&gt;</code>:</p>
<pre><code class="lang-XML">&lt;StackLayout id=&quot;container&quot;&gt;
</code></pre>
<p>Open <code>app/pages/login/login.component.ts</code> and add the following line at the top:</p>
<pre><code class="lang-TypeScript">import {Color} from &quot;color&quot;;
</code></pre>
<p>Change the <code>toggleDisplay()</code> function in the same file to look like this:</p>
<pre><code class="lang-TypeScript">toggleDisplay() {
  this.isLoggingIn = !this.isLoggingIn;
  this.page.getViewById(&quot;container&quot;).animate({
    backgroundColor: this.isLoggingIn ? new Color(&quot;white&quot;) : new Color(&quot;#301217&quot;),
    duration: 200
  });
}
</code></pre>
<div class="exercise-end"></div>

<p>Talk about the color module and animation module. Have gifs. Mention that the hint color looks bad, but that we’ll address that later. Transition to talking about the list page.</p>
<h3 id="listview">ListView</h3>
<h3 id="gridlayout">GridLayout</h3>
<h3 id="activityindicator">ActivityIndicator</h3>

			</div>
			<div class="chapter">
				<h2 id="plugins-and-npm-modules">Plugins and npm modules</h2>
<h3 id="npm-modules">npm modules</h3>
<h3 id="nativescript-plugins">NativeScript plugins</h3>

			</div>
			<div class="chapter">
				<h2 id="running-native-code">Running native code</h2>
<h3 id="accessing-native-apis">Accessing native APIs</h3>
<h3 id="branching-ios-android-code">Branching iOS &amp; Android code</h3>

			</div>
			<div class="chapter">
				<h2 id="next-steps">Next steps</h2>
<p>Your journey with NativeScript is just beginning. Here are some resources to help you figure out where to go from here.</p>
<ul>
<li>Follow <a href="https://twitter.com/nativescript">@nativescript</a> on Twitter for the latest and greatest news about NativeScript.</li>
<li>Join the <a href="http://developer.telerik.com/wp-login.php?action=slack-invitation">NativeScript Community Slack channel</a>. The channel is a great place to ask questions, and chat with others in the NativeScript community.</li>
<li>Subscribe to <a href="https://www.nativescript.org/blog">the NativeScript blog</a> for weekly articles. You can subscribe via RSS or email.</li>
<li>Look through the NativeScript <a href="https://www.nativescript.org/showcases">showcases</a> to get an idea of what people are building.</li>
<li>Check out our <a href="https://www.nativescript.org/resources">resources page</a> to find further NativeScript learning material, such as training, books, and screencasts.</li>
</ul>
<p>Finally, if you find an error in this guide, or have suggestions about how we can make it better, please file those ideas in <a href="https://github.com/tjvantoll/nativescript-angular-guide/issues">this guide&#39;s issue tracker</a> on GitHub.</p>

			</div>
		</div>
	</div>
</div>

<script src="scripts/built.js"></script>

</body>
</html>